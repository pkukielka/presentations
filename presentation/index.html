<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Using Lambdas for Scala code debugging</title>
	<meta name="description" content="Presentation about using Lambdas for Scala code debugging, which is not so trivial to support in tooling">
	<meta name="author" content="Krzysztof Romanowski">

	<meta name="apple-mobile-web-app-capable" content="yes"/>
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

	<meta name="viewport"
	      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<style type="text/css">
		.lefty { text-align: left; }
	</style>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>

<div class="reveal">

	<!-- Any section element inside of this container is displayed as a slide -->
	<div class="slides">

		<section data-markdown>
			<script type="text/template">
			### Krzysztof Romanowski

			romanowski.kr@gmail.com

			<div class="lefty" style="margin-left: 36%;">
				<img src="imgs/gh.png" style="background: none; border: none; margin: 0px"> romanowski
				<br/>
				<img src="imgs/twitter.png" style="background: none; border: none; margin: 0px"> RomanowskiKr

			</div>

			<img src="imgs/vl.png" alt="Virtus Lab" style="background: none; border: none; box-shadow: none"/>
			</script>
		</section>

		<!-- ################################################################################################################ -->

		<section>
			<section data-markdown>
				<script type="text/template">
				## Using Lambdas for Scala code debugging

				not so trivial to support in tooling
				</script>

			</section>

			<section data-markdown>
				<script type="text/template">
				## Plan

				1. Why do I need lambdas for Scala code debugging?
				2. Why labdas are not so trivial to support in tooling?
				3. What is done to support lambdas in ScalaIDE debugger?

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				I do not plan to introduce Expression Evaluator from ScalaIDE
				
				@Kwestor @mpociecha @pkukielka and @romanowski (me)
				
				Ask this guys for such presentation :)
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				All sources mentioned during presentation comes from ScalaIDE expression evaluator.

				https://github.com/scala-ide/scala-ide/tree/master/org.scala-ide.sdt.debug.expression
				</script>
			</section>

		</section>

		<section>
			<section data-markdown>
				<script type="text/template">
				## Why lambdas?
				</script>

			</section>
			<section data-markdown>
				<script type="text/template">
				## Collections

				```scala
				departaments.groupBy(_.location)

				employees.partion(employee => shouldBeTrusted(employee, "now"))

				bigMap.filter{ case (k,v) => k.startsWith("some")}

				entityList.map(_.nested1.nested2.nested3)

				//And many, many more!
				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				## Callbacks

				```scala
				inTransaction {
					findUsers()
				}
				```

				```scala
				var allUsers = Seq.empty[User]
				onUsers(user => allUsers += user)
				allUsers
				```
				</script>
			</section>


			<section data-markdown>
				<script type="text/template">
				And also combined as conditional breakpoints

				```scala
				users.forAll(_.salary > 4000)

				multiList.exist(_.exist(_.isNamed))
				
				inContext(members.isEmpty)
				```
				</script>
			</section>
		</section>
		<!-- ################################################################################################################ -->

		<section>
			<section data-markdown>
				<script type="text/template">
				#### not so trivial to support in tooling
				# Why?
				</script>

			</section>
			<section data-markdown>
				<script type="text/template">
				*Debugged JVM*: where application lives
				<br> &#8593;&#8593;&#8593;
				<br> JDI
				<br> &#8593;&#8593;&#8593;
				<br>*Debugging JVM*: where expression lives
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Our lamdas are created in *debugging* JVM

				but should live in *debugged* one.
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Problem 1:
				JDI-based class loading
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				```scala
				def myMethod(methodParam: Int): Unit = {
				  val localParam: Int = 12
				  //we are stopped at breakpoint here
				}
				```

				Since method params and local values are not members of any object and cannot be accessed in a way other than using JDI.
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Problem 2:
				Accessing runtime values:

				method parameters and local variables
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Lambdas are generic typed. In runtime all those lambdas has the same signature.
				```scala
				Int => Int
				Ala => Ola
				String => Map[Int, Double]
				```
				
				<br>
				
				Of course we can type such lambdas using e.g. presentation compiler but we can't always rely on in.
				
				Why we can't always rely on PC? Have you ever used Eclipse? :)
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Luckily function are contravariant. 
				

				```scala 
				// everywhere when we need
				Cat => Dog
				// we can use 
				Any => Dog.
				```
				
				So when we're missing generic types, we can type our lambdas as
				```scala
				Any => Any
				```
				</script>
			</section>
			
			<section data-markdown>
				<script type="text/template">
				
				Filter from Scala collection requires 
				```scala
				Any => Boolean
				```

				When we're missing full generic types for our lambda, then how can we compile filter correctly?
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Problem 3:
				Typing lambdas.

				Especially when we cannot rely on Presentation Compiler
				</script>
			</section>
		</section>

		<section>
			<section data-markdown>
				<script type="text/template">
				## Jdi based class loading
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Class load steps:

				1. Compile class to byte array
				2. Send class bytecode to debugged machine
				2. Define class in classload on debugged JVM
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				###  Compile cass to array of bytes
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Usually lambdas look like this (or at least should look):
				```scala
				_.toInt
				//or
				user => user.isSutiable
				//or
				list => list.map(_ + 2)
				```

				To classload we should translate this piece fo code so it can be compiled to .class file.
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Lambda:

				```scala
				user => user.isSutiable
				```

				is translated to

				```scala
				class CustomFunction extends Function1[User, Any]{
				  override def apply(user) => user.isSutiable
				}
				```

				and then compiled using toolbox.
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				#### Toolbox compilation output

				ls toolbox-output
				```
				__wrapper$1$6dbe9210e60f458c98e6e4b9b720f085
				__wrapper$16$f62dabc761474ea6bebf0555edaa9b11
				__wrapper$1$6fea4b9cf7de4073a3181c519e4c0c6f
				__wrapper$17$04134eae8de14694839ca932b6425c60
				...
				```

				ls toolbox-output/new-package

				```
				__wrapper$1$07d42f7a083d4b319b3aa57cce3ac6ca.class
				__wrapper$1$07d42f7a083d4b319b3aa57cce3ac6ca$CustomFunction$1.class
				__wrapper$1$07d42f7a083d4b319b3aa57cce3ac6ca$.class

				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### ClassListener

				1. Store all directories (packages) in toolbox output
				1. Compile lambda
				1. Find newly created directory (random named package)
				1. Gather all classes containing predefined lambda name (e.g. CustomLambda) from it

				<br/>

				<div class="lefty">details: AnonymousFunctionSupport.scala</div>
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Send class bytes to debugged machine
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				JDI allows us to send data to debugged JVM using:

				<br/>

				##### Any primitive - IntelliJ way

				create byte array on debugged JVM and set each byte

				<br/>

				##### String  - ScalaIDE way

				encode byte array as string, send and decode it again on debugged JVM (we are using Base64)
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				**Side note** Serious limiation of creating JDI base tools:

				<br/>

				#### We are limited to Java/Scala standard library on the side of debugged JVM.

				<br/>

				All other classes should be classloaded (what is not nice even for small lib containing ~20 class files)
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				```scala
				// encode with base64
				val localByteString = DatatypeConverter.printBase64Binary(code)

				// send to JDI
				val remoteByteStrings = jvm.mirrorOf(localByteString)

				val dateTypeConverterClazzRef =
				classByName("javax.xml.bind.DatatypeConverter")
				val parseMethodName = "parseBase64Binary"
				val parseMethod =
				methodOn(dateTypeConverterClazzRef, parseMethodName, arity = 1)

				// encoded
				val remoteByteArray = dateTypeConverterClazzReference.
				invokeMethod(currentThread, parseMethod, List(remoteByteStrings))
				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Define class using classloader on debugged jvm
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				```scala
				// defineClass(code: byte[], off: Int, len: Int)
				val methodSignature = "([BII)Ljava/lang/Class;"

				// obtain class loader for top stackframe class
				val classLoaderRef =
				  currentFrame.thisObject.referenceType.classLoader

				val defineClassMethod = classLoaderRef.referenceType
				  .methodsByName("defineClass", methodSignature).head

				// load the class
				classLoaderRef
				  .invokeMethod(currentThread, defineClassMethod, classData)
				  .asInstanceOf[ClassObjectReference]
				```
				</script>
			</section>


			<section data-markdown>
				<script type="text/template">
				## Jdi based class loading

				<img src="imgs/solved.gif" style="background: none; border: none; margin-top: -60px">
				</script>
			</section>
		</section>

		<section>
			<section data-markdown>
				<script type="text/template">
				### Accessing runtime values:

				method parameters and local variables
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				## Closures
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Simple Scala lambda with closure

				```scala
				val outer = 123
				list.map(_ + outer)
				```
				is compiled to (excluding implicits)

				```scala
				val outer = 123
				class Lambda(outer: Int) extends Function1[Int] {
					def apply(v: Int): Int = v + outer
				}

				list.map(new Lambda(outer))
				```
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				What we need to do:

				1. Find all closure parameters
				2. Inject those values to created lambda
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				## Find all closure parameters
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				### Traverser

				```scala
				final override def traverse(tree: Tree): Unit = {
				  tree match {
				    // all identifiers
				    case Ident(name: TermName) if !scopeManager.insideImport =>
				       nameManager.registerUnboundName(name, tree, isLocal = false)

				    //typed expression like x: Int
				    case restTree @ Typed(impl, _) =>
				        super.traverse(impl)

				    case _ => super.traverse(tree)
				}
				```
				<br/>
				<div class="lefty">more:  UnboundValuesSupport.scala</div>
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				VariableProxyTraverser

				Finds all unbound identifiers.

				Value is bound if current scope is:

				1. value/variable/def definition
				1. named parameter
				1. pattern in case or for-comprehension
				1. lambda implementation parameter

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Wait! What with packages?

				```scala
				_ => mutable.Set.empty[String]
				```
				mutable is unbound!
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				The biggest AST transformer problem:

				#### You always forget about some tree shapes!
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Sidenote

				Toolbox has poor support for packages.

				https://issues.scala-lang.org/browse/SI-6393

				Reason: Packages are "phantom" in JVM implementation (cannot be enumerated simply).
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				## Inject closure values to created lambda
				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				Let's translate

				```scala
				val closureParam = 1
				list.map(_ + closureParam)
				```
				to

				```scala
				val closureParam = 1
				list.map(
				__contex.newInstance("random-lambda-name", Seq(closureParam))
				```

				</script>
			</section>

			<section data-markdown>
				<script type="text/template">
				In Scala AST:

				```scala
				val constructorArgs =
					Literal(Constant(newFunctionType)) ::
					Apply(SelectApplyMethod("Seq"), closureArgs) ::
					Nil

				//__contex.newInstance("random-lambda-name", Seq(closureParam))
				val newInstanceCall = Apply(
				  Select(
				    Ident(TermName(Debugger.contextParamName)),
				    TermName(Debugger.newInstance)
				   ),
				  constructorArgs
				)
				```

				</script>
			</section>


			<section data-markdown>
				<script type="text/template">
				### Accessing runtime values:

				method parameters and local variables

				<img src="imgs/solved.gif" style="background: none; border: none; margin-top: -60px">
				</script>
			</section>
		</section>

		<section>
			<section data-markdown>
				<script type="text/template">
				## Typing lambdas
				</script>
			</section>
		
		
			<section data-markdown>
				<script type="text/template">
				## Typing lambdas.

				Especially when we cannot rely on Presentation Compiler
				<img src="imgs/solved.gif" style="background: none; border: none; margin-top: -40px">
				</script>
			</section>
		</section>

		<section>
			<section data-markdown>
				<script type="text/template">
				## Contribute for your and greater good!

				github.com/scala-ide/scala-ide
				</script>
			</section>
		</section>

		<!-- ################################################################################################################ -->
	</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});











</script>

</body>
</html>
adventurous
